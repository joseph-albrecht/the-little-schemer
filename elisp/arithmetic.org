* RECURSIVE ADDITION OF TWO NUMBERS
** MY FUNCTION
#+BEGIN_SRC emacs-lisp
(defun plus (first second)
  (cond
   ((= first 0)
    (cond
     ((= second 0) 0)
     (t (1+ (plus first (1- second))))))
   (t (1+ (plus (1- first) second)))))

#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp
(plus 3 4)
#+END_SRC
** BOOK FUNCTION
#+BEGIN_SRC emacs-lisp
(defun book-plus (first second)
  (cond
   ((= second 0) first)
   (t (1+ (book-plus first (1- second))))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp
(book_plus 3 4)
#+END_SRC

* RECURSIVE ADDITION OF NUMBERS IN A LIST
** FUNCTION
#+BEGIN_SRC emacs-lips
(defun addtup (tup)
  "adds all the integers in the tup"
  (cond
   ((null tup) 0)
   (t (+ (car tup) (addtup (cdr tup))))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp
(addtup '(5 6 7 8))
#+END_SRC
* RECURSIVE SUBTRACTION OF TWO NUMBERS
** FUNCTION
#+BEGIN_SRC emacs-lisp
(defun sub (first second)
  "Subtract the second number from the first number"
  (cond
   ((= second 0) first)
   (t (1- (sub first (1- second))))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp
(sub 3 1)
(sub 300 100)
#+END_SRC
* RECURSIVE MULTIPLICATION
** FUNCTION
#+BEGIN_SRC emacs-lisp
  (defun mult (num1 num2)
    "multiply two numbers recursively"
    (cond
     ((eq num2 0) 0)
     (t (+
         num1
         (mult num1 (1- num2))))))

#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp :results output
  (princ
   (format "10 x 10: %d \n9 x 9: %d \n5 x 5: %d"
           (mult 10 10)
           (mult 9 9)
           (mult 5 5)))
#+END_SRC

#+RESULTS:
: 10 x 10: 100 
: 9 x 9: 81 
: 5 x 5: 25

* RECURSIVE ADDITION OF SAME LENGTH LISTS
** FUNCTION
#+BEGIN_SRC emacs-lisp
(defun tup+ (tup1 tup2)
  "evaluates the numbers in tup1 to tup2"
  (cond
   ((and (null tup1) (null tup2))
    ())
   (t (cons
       (+ (car tup1) (car tup2))
       (tup+ (cdr tup1) (cdr tup2))))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp
(tup+ '(1 2 3) '(2 3 4))
#+END_SRC
* RECURSIVE ADDITION OF DIFFERENT LENGTH LISTS
** FUNCTION
#+BEGIN_SRC emacs-lisp
(defun tup+better(tup1 tup2)
  (cond
   ((and (null tup1) (null tup2))
    ())
   ((null tup1) tup2)
   ((null tup2) tup1)
   (t (cons
       (+ (car tup1) (car tup2))
       (tup+better (cdr tup1) (cdr tup2)))))) 
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp
(tup+better '(1) '(2 3 4)) 
(tup+better '(1 2) '(2)) 
(tup+better '(2 3 4) '(1)) 
#+END_SRC
* RECURSIVE EXPONENTIAL FUNCTION
** FUNCTION
#+BEGIN_SRC emacs-lisp
  (defun exp (base exponent)
    "raise the base to the exponent"
    (cond
     ((eq exponent 0) 1)
     (t (*
         base
         (exp base (1- exponent))))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp :results output
  (princ
   (format "2^1: %d \n2^2: %d \n2^3: %d"
           (exp 2 1)
           (exp 2 2)
           (exp 2 3)))
#+END_SRC

#+RESULTS:
: 2^1: 2 
: 2^2: 4 
: 2^3: 8

* RECURSIVE LENGTH OF LIST
** FUNCTION
#+BEGIN_SRC emacs-lisp
  (defun length (lat)
    "count the number of atoms in a list"
    (cond
     ((null lat) 0)
     (t (1+ (length (cdr lat))))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp :results output
  (princ
   (format "(a b): %d \n(a b c): %d"
           (length '(a b))
           (length '(a b c))))
#+END_SRC

#+RESULTS:
: (a b): 2 
: (a b c): 3
* RECURSIVE SELECT ELEMENT
** FUNCTION
#+BEGIN_SRC emacs-lisp
  (defun pick (n lat)
    "pick element n from lat"
    (cond
     ((< n 1) nil)
     ((> n (length lat)) nil)
     ((eq n 1) (car lat))
     (t (pick (1- n) (cdr lat)))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp :results output
  (princ
   (format "pick 2 from (a b): %s"
           (pick 2 '(a b))))
#+END_SRC

#+RESULTS:
: pick 2 from (a b): b

* RECURSIVE REMOVE ELEMENT AT INDEX...
** FUNCTION
#+BEGIN_SRC emacs-lisp
  (defun rempick (i lat)
    "remove atom at index i from lat"
    (cond
     ((eq i 1) (cdr lat))
     ((> i (length lat)) (lat))
     (t (cons
         (car lat)
         (rempick (1- i) (cdr lat))))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp :results output
  (princ
   (format "removing index 2 from (one two three) produces: %s"
           (rempick 2 '(one two three))))
  (princ
   (format "\nremoving index 3 from (one two three) produces: %s"
           (rempick 3 '(one two three))))
#+END_SRC

#+RESULTS:
: removing index 2 from (one two three) produces: (one three)
: removing index 3 from (one two three) produces: (one two)
* RECURSIVE REMOVE NUMBERS
** FUNCTION
#+BEGIN_SRC emacs-lisp
  (defun no-nums (lat)
    "remove numbers from lat"
    (cond
     ((eq (length lat) 0) ())
     ((numberp (car lat)) (no-nums (cdr lat)))
     (t (cons
         (car lat)
         (no-nums (cdr lat))))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp
  (princ
   (format "removing the numbers from (5 pears 6 prunes 9 dates):\n%s"
           (no-nums '(5 pears 6 prunes 9 dates))))
#+END_SRC

#+RESULTS:
: removing the numbers from (5 pears 6 prunes 9 dates):
: (pears prunes dates)
* RECURSIVE REMOVE NON NUMBERS
** FUNCTION
#+BEGIN_SRC emacs-lisp
  (defun all-nums (lat)
    "returns all the numbers in a lat"
    (cond
     ((eq (length lat) 0) ())
     ((numberp (car lat))
      (cons
       (car lat)
       (all-nums (cdr lat))))
     (t (all-nums (cdr lat)))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp
  (princ
   (format "all the numbers in (5 pears 6 prunes 9 dates is:\n%s"
           (all-nums '(5 pears 6 prunes 9 dates))))
#+END_SRC

#+RESULTS:
: all the numbers in (5 pears 6 prunes 9 dates is:
: (5 6 9)
* FUNCTION COMPARE ATOMS
** FUNCTION
#+BEGIN_SRC emacs-lisp
  (defun occur (a lat)
    "returns how many times a is in lat"
    (cond
     ((null lat) 0)
     ((equal a (car lat))
      (1+ (occur a (cdr lat))))
     (t
      (occur a (cdr lat)))))
#+END_SRC
** TEST CALLS
#+BEGIN_SRC emacs-lisp :results output
  (princ
   (format "a is in (a a a b c a): %s times"
           (occur 'a '(a a a b c a))))
(occur 1 '(1 1 1))
#+END_SRC
#+RESULTS:
: a is in (a a a b c a): 4 times

